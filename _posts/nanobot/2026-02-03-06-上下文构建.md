# ç¬¬ä¸‰å±‚ï¼šä¸Šä¸‹æ–‡æ„å»º

> ğŸ“Œ **æ ¸å¿ƒæ–‡ä»¶**ï¼š`nanobot/agent/context.py` (~218 è¡Œ)

## æ¦‚è¿°

`ContextBuilder` è´Ÿè´£ç»„è£…å‘é€ç»™ LLM çš„å®Œæ•´ä¸Šä¸‹æ–‡ï¼ŒåŒ…æ‹¬ç³»ç»Ÿæç¤ºã€è®°å¿†ã€æŠ€èƒ½ã€å¯¹è¯å†å²ç­‰ã€‚è¿™æ˜¯ Agent "çœ‹åˆ°çš„ä¸–ç•Œ"ã€‚

## ä¸Šä¸‹æ–‡çš„ç»„æˆ

ä¸€ä¸ªå®Œæ•´çš„ LLM è¯·æ±‚åŒ…å«ï¼š

```python
messages = [
    {
        "role": "system",
        "content": "ç³»ç»Ÿæç¤ºï¼ˆç”± ContextBuilder ç»„è£…ï¼‰"
    },
    {
        "role": "user",
        "content": "ä¹‹å‰çš„ç”¨æˆ·æ¶ˆæ¯1"
    },
    {
        "role": "assistant",
        "content": "ä¹‹å‰çš„åŠ©æ‰‹å›å¤1"
    },
    # ... æ›´å¤šå†å² ...
    {
        "role": "user",
        "content": "å½“å‰ç”¨æˆ·æ¶ˆæ¯"
    }
]
```

## ç³»ç»Ÿæç¤ºçš„ç»“æ„

### å®Œæ•´ç»„æˆ

```markdown
# 1. æ ¸å¿ƒèº«ä»½
- å½“å‰æ—¶é—´
- å·¥ä½œåŒºè·¯å¾„  
- åŸºæœ¬æŒ‡ä»¤

# 2. Bootstrap æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
## AGENTS.md
ï¼ˆAgent è¡Œä¸ºè§„èŒƒï¼‰

## SOUL.md
ï¼ˆä¸ªæ€§åŒ–è®¾å®šï¼‰

## USER.md
ï¼ˆç”¨æˆ·ä¿¡æ¯ï¼‰
# 3. è®°å¿†
ä» MEMORY.md å’Œæ¯æ—¥ç¬”è®°åŠ è½½

# 4. æŠ€èƒ½
## å§‹ç»ˆåŠ è½½çš„æŠ€èƒ½ï¼ˆå®Œæ•´å†…å®¹ï¼‰
...

## å¯ç”¨æŠ€èƒ½ï¼ˆä»…æ‘˜è¦ï¼‰
...

```

### ä»£ç å®ç°

```python
class ContextBuilder:
    BOOTSTRAP_FILES = ["AGENTS.md", "SOUL.md", "USER.md", "TOOLS.md", "IDENTITY.md"]
    
    def __init__(self, workspace: Path):
        self.workspace = workspace
        self.memory = MemoryStore(workspace)
        self.skills = SkillsLoader(workspace)
    
    def build_system_prompt(self, skill_names: list[str] | None = None) -> str:
        """æ„å»ºå®Œæ•´çš„ç³»ç»Ÿæç¤º"""
        parts = []
        
        # 1. æ ¸å¿ƒèº«ä»½
        parts.append(self._get_identity())
        
        # 2. Bootstrap æ–‡ä»¶
        bootstrap = self._load_bootstrap_files()
        if bootstrap:
            parts.append(bootstrap)
        
        # 3. è®°å¿†
        memory = self.memory.get_memory_context()
        if memory:
            parts.append(f"# Memory\n\n{memory}")
        
        # 4. æŠ€èƒ½
        always_skills = self.skills.get_always_skills()
        if always_skills:
            always_content = self.skills.load_skills_for_context(always_skills)
            parts.append(f"# Active Skills\n\n{always_content}")
        
        skills_summary = self.skills.build_skills_summary()
        if skills_summary:
            parts.append(f"""# Skills

The following skills extend your capabilities. To use a skill, read its SKILL.md file.

{skills_summary}""")
        
        return "\n\n---\n\n".join(parts)
```

## æ ¸å¿ƒèº«ä»½

```python
def _get_identity(self) -> str:
    """è·å–æ ¸å¿ƒèº«ä»½éƒ¨åˆ†"""
    from datetime import datetime
    now = datetime.now().strftime("%Y-%m-%d %H:%M (%A)")
    workspace_path = str(self.workspace.expanduser().resolve())
    
    return f"""# nanobot ğŸˆ

You are nanobot, a helpful AI assistant. You have access to tools that allow you to:
- Read, write, and edit files
- Execute shell commands
- Search the web and fetch web pages
- Send messages to users on chat channels
- Spawn subagents for complex background tasks

## Current Time
{now}

## Workspace
Your workspace is at: {workspace_path}
- Memory files: {workspace_path}/memory/MEMORY.md
- Daily notes: {workspace_path}/memory/YYYY-MM-DD.md
- Custom skills: {workspace_path}/skills/{{skill-name}}/SKILL.md

IMPORTANT: When responding to direct questions or conversations, reply directly with your text response.
Only use the 'message' tool when you need to send a message to a specific chat channel.

Always be helpful, accurate, and concise."""
```

## Bootstrap æ–‡ä»¶

ç”¨æˆ·å¯ä»¥åœ¨å·¥ä½œåŒºåˆ›å»ºè¿™äº›æ–‡ä»¶æ¥å®šåˆ¶ Agentï¼š

```python
def _load_bootstrap_files(self) -> str:
    """åŠ è½½æ‰€æœ‰ Bootstrap æ–‡ä»¶"""
    parts = []
    
    for filename in self.BOOTSTRAP_FILES:
        file_path = self.workspace / filename
        if file_path.exists():
            content = file_path.read_text(encoding="utf-8")
            parts.append(f"## {filename}\n\n{content}")
    
    return "\n\n".join(parts) if parts else ""
```

**ç¤ºä¾‹ - SOUL.md**ï¼ˆèµ‹äºˆ Agent ä¸ªæ€§ï¼‰ï¼š

```markdown
You are a friendly and patient assistant.
You prefer to explain concepts step by step.
When users make mistakes, you gently correct them.
```

## æ¶ˆæ¯æ„å»º

### å®Œæ•´çš„æ¶ˆæ¯åˆ—è¡¨

```python
def build_messages(
    self,
    history: list[dict[str, Any]],
    current_message: str,
    skill_names: list[str] | None = None,
    media: list[str] | None = None,
) -> list[dict[str, Any]]:
    """æ„å»ºå®Œæ•´çš„æ¶ˆæ¯åˆ—è¡¨"""
    messages = []
    
    # ç³»ç»Ÿæç¤º
    system_prompt = self.build_system_prompt(skill_names)
    messages.append({"role": "system", "content": system_prompt})
    
    # å†å²æ¶ˆæ¯
    messages.extend(history)
    
    # å½“å‰æ¶ˆæ¯ï¼ˆå¯èƒ½åŒ…å«å›¾ç‰‡ï¼‰
    user_content = self._build_user_content(current_message, media)
    messages.append({"role": "user", "content": user_content})
    
    return messages
```

### æ”¯æŒå›¾ç‰‡è¾“å…¥

```python
def _build_user_content(self, text: str, media: list[str] | None):
    """æ„å»ºç”¨æˆ·æ¶ˆæ¯ï¼ˆæ”¯æŒå›¾ç‰‡ï¼‰"""
    if not media:
        return text
    
    # è½¬æ¢å›¾ç‰‡ä¸º base64
    images = []
    for path in media:
        p = Path(path)
        mime, _ = mimetypes.guess_type(path)
        if not p.is_file() or not mime or not mime.startswith("image/"):
            continue
        
        b64 = base64.b64encode(p.read_bytes()).decode()
        images.append({
            "type": "image_url",
            "image_url": {"url": f"data:{mime};base64,{b64}"}
        })
    
    if not images:
        return text
    
    # OpenAI æ ¼å¼ï¼šåˆ—è¡¨ [image, image, text]
    return images + [{"type": "text", "text": text}]
```

**ç”Ÿæˆçš„æ¶ˆæ¯æ ¼å¼**ï¼š

```json
{
  "role": "user",
  "content": [
    {
      "type": "image_url",
      "image_url": {
        "url": "data:image/jpeg;base64,/9j/4AAQSkZJRg..."
      }
    },
    {
      "type": "text",
      "text": "è¿™å¼ å›¾ç‰‡é‡Œæœ‰ä»€ä¹ˆï¼Ÿ"
    }
  ]
}
```

## å·¥å…·è°ƒç”¨çš„æ¶ˆæ¯å¤„ç†

### æ·»åŠ åŠ©æ‰‹æ¶ˆæ¯ï¼ˆå¸¦å·¥å…·è°ƒç”¨ï¼‰

```python
def add_assistant_message(
    self,
    messages: list[dict[str, Any]],
    content: str | None,
    tool_calls: list[dict[str, Any]] | None = None
) -> list[dict[str, Any]]:
    """æ·»åŠ åŠ©æ‰‹æ¶ˆæ¯åˆ°æ¶ˆæ¯åˆ—è¡¨"""
    msg = {"role": "assistant", "content": content or ""}
    
    if tool_calls:
        msg["tool_calls"] = tool_calls
    
    messages.append(msg)
    return messages
```

### æ·»åŠ å·¥å…·ç»“æœ

```python
def add_tool_result(
    self,
    messages: list[dict[str, Any]],
    tool_call_id: str,
    tool_name: str,
    result: str
) -> list[dict[str, Any]]:
    """æ·»åŠ å·¥å…·æ‰§è¡Œç»“æœ"""
    messages.append({
        "role": "tool",
        "tool_call_id": tool_call_id,
        "name": tool_name,
        "content": result
    })
    return messages
```

## å®Œæ•´çš„å¯¹è¯ç¤ºä¾‹

ç”¨æˆ·ï¼š**"è¯»å– config.json æ–‡ä»¶å¹¶æ€»ç»“"**

### ç¬¬ä¸€è½® LLM è°ƒç”¨

```python
messages = [
    {
        "role": "system",
        "content": "# nanobot ğŸˆ\n\n..."  # å®Œæ•´ç³»ç»Ÿæç¤º
    },
    {
        "role": "user",
        "content": "è¯»å– config.json æ–‡ä»¶å¹¶æ€»ç»“"
    }
]
```

### LLM è¿”å›å·¥å…·è°ƒç”¨

```json
{
  "role": "assistant",
  "content": null,
  "tool_calls": [{
    "id": "call_123",
    "type": "function",
    "function": {
      "name": "read_file",
      "arguments": "{\"path\": \"config.json\"}"
    }
  }]
}
```

### æ·»åŠ å·¥å…·è°ƒç”¨å’Œç»“æœ

```python
# æ·»åŠ  LLM çš„å·¥å…·è°ƒç”¨
messages = builder.add_assistant_message(
    messages, 
    content=None, 
    tool_calls=[...]
)

# æ‰§è¡Œå·¥å…·
result = await tools.execute("read_file", {"path": "config.json"})

# æ·»åŠ å·¥å…·ç»“æœ
messages = builder.add_tool_result(
    messages,
    tool_call_id="call_123",
    tool_name="read_file",
    result=result
)
```

ç°åœ¨ messages å˜æˆï¼š

```python
[
    {"role": "system", "content": "..."},
    {"role": "user", "content": "è¯»å– config.json æ–‡ä»¶å¹¶æ€»ç»“"},
    {
        "role": "assistant",
        "content": None,
        "tool_calls": [...]
    },
    {
        "role": "tool",
        "tool_call_id": "call_123",
        "name": "read_file",
        "content": "æ–‡ä»¶å†…å®¹ï¼š{...}"
    }
]
```

### ç¬¬äºŒè½® LLM è°ƒç”¨

LLM çœ‹åˆ°å·¥å…·ç»“æœåç”Ÿæˆæ€»ç»“ï¼š

```json
{
  "role": "assistant",
  "content": "è¿™ä¸ªé…ç½®æ–‡ä»¶åŒ…å«äº†ä»¥ä¸‹è®¾ç½®ï¼š..."
}
```

## ä¸Šä¸‹æ–‡é•¿åº¦ç®¡ç†

è™½ç„¶å½“å‰å®ç°æ²¡æœ‰é™åˆ¶å†å²é•¿åº¦ï¼Œä½†å¯ä»¥è½»æ¾æ·»åŠ ï¼š

```python
def build_messages(self, history, current_message, max_history=20):
    """é™åˆ¶å†å²æ¶ˆæ¯æ•°é‡"""
    messages = []
    
    # ç³»ç»Ÿæç¤º
    messages.append({"role": "system", "content": system_prompt})
    
    # åªä¿ç•™æœ€è¿‘ N æ¡å†å²
    recent_history = history[-max_history:] if len(history) > max_history else history
    messages.extend(recent_history)
    
    # å½“å‰æ¶ˆæ¯
    messages.append({"role": "user", "content": current_message})
    
    return messages
```

## åŠ¨æ€æŠ€èƒ½åŠ è½½

ContextBuilder æ”¯æŒä¸¤ç§æŠ€èƒ½åŠ è½½æ–¹å¼ï¼š

### 1. å§‹ç»ˆåŠ è½½çš„æŠ€èƒ½

```python
# skills/github/SKILL.md
---
name: github
always_load: true  # å§‹ç»ˆåŠ è½½å®Œæ•´å†…å®¹
---

# GitHub Skill
...
```

### 2. æŒ‰éœ€åŠ è½½çš„æŠ€èƒ½

```python
# skills/weather/SKILL.md
---
name: weather
available: true  # ä»…æ˜¾ç¤ºåœ¨æ‘˜è¦ä¸­ï¼ŒAgent éœ€è¦æ—¶è¯»å–
---

# Weather Skill
...
```

LLM ä¼šçœ‹åˆ°ï¼š

```markdown
# Skills

The following skills are available. To use a skill, read its SKILL.md file.

- **weather** - Get weather information
  Location: ~/.nanobot/skills/weather/SKILL.md
```

## å°ç»“

- âœ… æ¨¡å—åŒ–çš„ç³»ç»Ÿæç¤ºæ„å»º
- âœ… Bootstrap æ–‡ä»¶æ”¯æŒå®šåˆ¶åŒ–
- âœ… è‡ªåŠ¨é›†æˆè®°å¿†å’ŒæŠ€èƒ½
- âœ… æ”¯æŒå›¾ç‰‡è¾“å…¥ï¼ˆVision æ¨¡å‹ï¼‰
- âœ… å·¥å…·è°ƒç”¨çš„æ¶ˆæ¯ç®¡ç†

**ä¸‹ä¸€æ­¥**ï¼š[07-ä¼šè¯ç®¡ç†.md](./nanobot/2026-02-03/07-ä¼šè¯ç®¡ç†.md)
