# ç¬¬å…­å±‚ï¼šæ¸ é“ç®¡ç†

> ğŸ“Œ **æ ¸å¿ƒæ–‡ä»¶**ï¼š`nanobot/channels/manager.py`  
> **æ”¯æŒæ¸ é“**ï¼šTelegram, WhatsApp, CLI

## æ¦‚è¿°

æ¸ é“ï¼ˆChannelï¼‰æ˜¯ nanobot ä¸ç”¨æˆ·äº¤äº’çš„å‰ç«¯æ¥å£ã€‚é€šè¿‡ç»Ÿä¸€çš„æ¶ˆæ¯æ€»çº¿ï¼Œnanobot å¯ä»¥åŒæ—¶æ”¯æŒå¤šç§èŠå¤©å¹³å°ã€‚

## Channel æŠ½è±¡æ¥å£

```python
class Channel(ABC):
    """æ¸ é“æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    async def start(self):
        """å¯åŠ¨æ¸ é“ç›‘å¬"""
        pass
    
    @abstractmethod
    async def send_message(self, msg: OutboundMessage):
        """å‘é€æ¶ˆæ¯åˆ°ç”¨æˆ·"""
        pass
```

## æ¸ é“å·¥ä½œæµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·ï¼ˆTelegram/WhatsAppï¼‰
    participant Channel as Channel
    participant Bus as MessageBus
    participant Agent as Agent

    User->>Channel: å‘é€æ¶ˆæ¯
    Channel->>Bus: publish_inbound(msg)
    Bus->>Agent: consume_inbound()
    Agent->>Agent: å¤„ç†æ¶ˆæ¯
    Agent->>Bus: publish_outbound(response)
    Bus->>Channel: dispatch â†’ callback
    Channel->>User: å‘é€å“åº”
```

## æ”¯æŒçš„æ¸ é“

### 1. Telegram Bot

**é…ç½®**ï¼š
```json
{
  "channels": {
    "telegram": {
      "enabled": true,
      "token": "123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11",
      "allowFrom": ["123456789", "987654321"]
    }
  }
}
```

**å®ç°**ï¼š

```python
from telegram import Update
from telegram.ext import Application, MessageHandler, filters

class TelegramChannel:
    def __init__(self, config, bus: MessageBus):
        self.config = config
        self.bus = bus
        self.app = Application.builder().token(config.token).build()
        
        # è®¢é˜…å‡ºç«™æ¶ˆæ¯
        bus.subscribe_outbound("telegram", self.send_message)
    
    async def start(self):
        """å¯åŠ¨ Telegram Bot"""
        # æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
        self.app.add_handler(
            MessageHandler(filters.TEXT & ~filters.COMMAND, self.on_message)
        )
        
        # è¿è¡Œ
        await self.app.run_polling()
    
    async def on_message(self, update: Update, context):
        """æ¥æ”¶ Telegram æ¶ˆæ¯"""
        user_id = str(update.effective_user.id)
        
        # æ£€æŸ¥æƒé™
        if self.config.allowFrom and user_id not in self.config.allowFrom:
            await update.message.reply_text("Unauthorized")
            return
        
        # å‘å¸ƒåˆ°æ¶ˆæ¯æ€»çº¿
        await self.bus.publish_inbound(InboundMessage(
            channel="telegram",
            sender_id=user_id,
            chat_id=str(update.effective_chat.id),
            content=update.message.text,
            session_key=f"telegram:{update.effective_chat.id}"
        ))
    
    async def send_message(self, msg: OutboundMessage):
        """å‘é€æ¶ˆæ¯ï¼ˆè®¢é˜…å›è°ƒï¼‰"""
        if msg.channel == "telegram":
            await self.app.bot.send_message(
                chat_id=msg.chat_id,
                text=msg.content
            )
```

**ç‰¹ç‚¹**ï¼š
- åŸºäº `python-telegram-bot`
- æ”¯æŒç™½åå•ï¼ˆ`allowFrom`ï¼‰
- è‡ªåŠ¨ long polling

### 2. WhatsApp

**æ¶æ„**ï¼š

```
Node.js WhatsAppåº“ (whatsapp-web.js)
         â†•
    WebSocket æ¡¥æ¥
         â†•
  Python WhatsAppChannel
         â†•
     MessageBus
```

**é…ç½®**ï¼š
```json
{
  "channels": {
    "whatsapp": {
      "enabled": true,
      "allowFrom": ["+1234567890"]
    }
  }
}
```

**Python ç«¯å®ç°**ï¼š

```python
class WhatsAppChannel:
    def __init__(self, config, bus: MessageBus):
        self.config = config
        self.bus = bus
        self.ws = None
        
        bus.subscribe_outbound("whatsapp", self.send_message)
    
    async def start(self):
        """è¿æ¥åˆ° Node.js æ¡¥æ¥"""
        async with websockets.connect("ws://localhost:8765") as ws:
            self.ws = ws
            
            async for message in ws:
                data = json.loads(message)
                
                if data["type"] == "message":
                    await self.on_whatsapp_message(data)
    
    async def on_whatsapp_message(self, data):
        sender = data["from"]
        
        # æ£€æŸ¥æƒé™
        if self.config.allowFrom and sender not in self.config.allowFrom:
            return
        
        await self.bus.publish_inbound(InboundMessage(
            channel="whatsapp",
            sender_id=sender,
            chat_id=sender,
            content=data["body"],
            session_key=f"whatsapp:{sender}"
        ))
    
    async def send_message(self, msg: OutboundMessage):
        if msg.channel == "whatsapp" and self.ws:
            await self.ws.send(json.dumps({
                "type": "send",
                "to": msg.chat_id,
                "message": msg.content
            }))
```

**Node.js æ¡¥æ¥**ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼š

```javascript
const { Client } = require('whatsapp-web.js');
const WebSocket = require('ws');

const client = new Client();
const wss = new WebSocket.Server({ port: 8765 });

wss.on('connection', (ws) => {
  // æ¥æ”¶ WhatsApp æ¶ˆæ¯
  client.on('message', (msg) => {
    ws.send(JSON.stringify({
      type: 'message',
      from: msg.from,
      body: msg.body
    }));
  });
  
  // å‘é€æ¶ˆæ¯
  ws.on('message', (data) => {
    const cmd = JSON.parse(data);
    if (cmd.type === 'send') {
      client.sendMessage(cmd.to, cmd.message);
    }
  });
});

client.initialize();
```

### 3. CLI

CLI ä¸æ˜¯çœŸæ­£çš„"æ¸ é“"ï¼Œä½†å®ç°äº†ç›¸åŒçš„æ¥å£ï¼š

```python
# åœ¨ nanobot agent å‘½ä»¤ä¸­
response = await agent.process_direct(message, session_key)
console.print(response)
```

## ChannelManager

ç»Ÿä¸€ç®¡ç†æ‰€æœ‰æ¸ é“ï¼š

```python
class ChannelManager:
    """æ¸ é“ç®¡ç†å™¨"""
    
    def __init__(self, config, bus: MessageBus):
        self.config = config
        self.bus = bus
        self.channels = []
        
        # åˆå§‹åŒ–å¯ç”¨çš„æ¸ é“
        if config.channels.telegram and config.channels.telegram.enabled:
            self.channels.append(TelegramChannel(config.channels.telegram, bus))
        
        if config.channels.whatsapp and config.channels.whatsapp.enabled:
            self.channels.append(WhatsAppChannel(config.channels.whatsapp, bus))
    
    async def start(self):
        """å¹¶å‘å¯åŠ¨æ‰€æœ‰æ¸ é“"""
        await asyncio.gather(*[ch.start() for ch in self.channels])
```

## æƒé™æ§åˆ¶

### allowFrom ç™½åå•

```json
{
  "telegram": {
    "allowFrom": ["123456", "789012"]  // åªå…è®¸è¿™äº›ç”¨æˆ·
  }
}
```

**å®ç°**ï¼š
```python
if self.config.allowFrom and user_id not in self.config.allowFrom:
    await update.message.reply_text("â›” Unauthorized")
    return
```

### æœªæ¥æ‰©å±•ï¼šè§’è‰²å’Œæƒé™

```json
{
  "users": {
    "123456": {"role": "admin", "permissions": ["all"]},
    "789012": {"role": "user", "permissions": ["read", "execute"]}
  }
}
```

## å¤šæ¸ é“å¹¶å‘

```python
# åœ¨ gateway ä¸­
await asyncio.gather(
    agent.run(),
    bus.dispatch_outbound(),
    channel_manager.start(),  # åŒæ—¶å¯åŠ¨æ‰€æœ‰æ¸ é“
  cron_service.start(),
)
```

**ç”¨æˆ·ä½“éªŒ**ï¼š
- å¯ä»¥åŒæ—¶ä» Telegram å’Œ WhatsApp ä¸ Agent å¯¹è¯
- æ¯ä¸ªæ¸ é“æœ‰ç‹¬ç«‹çš„ä¼šè¯
- Agent å“åº”ä¼šå‘å›åŸå§‹æ¸ é“

## æ·»åŠ æ–°æ¸ é“

### æ­¥éª¤

1. **å®ç° Channel æ¥å£**ï¼š

```python
class DiscordChannel:
    def __init__(self, config, bus):
        self.config = config
        self.bus = bus
        bus.subscribe_outbound("discord", self.send_message)
    
    async def start(self):
        # è¿æ¥ Discord API
        # ç›‘å¬æ¶ˆæ¯
        # å‘å¸ƒåˆ° bus
        pass
    
    async def send_message(self, msg):
        # å‘é€åˆ° Discord
        pass
```

2. **æ·»åŠ é…ç½®**ï¼š

```json
{
  "channels": {
    "discord": {
      "enabled": true,
      "token": "discord-bot-token",
      "allowFrom": ["discord-user-id"]
    }
  }
}
```

3. **åœ¨ ChannelManager ä¸­æ³¨å†Œ**ï¼š

```python
if config.channels.discord and config.channels.discord.enabled:
    self.channels.append(DiscordChannel(config.channels.discord, bus))
```

## å°ç»“

- âœ… ç»Ÿä¸€çš„ Channel æ¥å£
- âœ… åŸºäºæ¶ˆæ¯æ€»çº¿è§£è€¦
- âœ… æ”¯æŒå¤šæ¸ é“å¹¶å‘
- âœ… æƒé™æ§åˆ¶ï¼ˆç™½åå•ï¼‰
- âœ… æ˜“äºæ‰©å±•æ–°æ¸ é“

**ä¸‹ä¸€æ­¥**ï¼š[14-å®šæ—¶ä»»åŠ¡.md](./nanobot/2026-02-03/14-å®šæ—¶ä»»åŠ¡.md)
