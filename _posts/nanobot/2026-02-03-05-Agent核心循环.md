# ç¬¬äº”å±‚ï¼šAgent æ ¸å¿ƒå¾ªç¯

> ğŸ“Œ **æ ¸å¿ƒæ–‡ä»¶**ï¼š`nanobot/agent/loop.py` (~330 è¡Œ)  
> è¿™æ˜¯ nanobot çš„å¤§è„‘ï¼Œç†è§£è¿™ä¸ªæ–‡ä»¶å°±ç†è§£äº†æ•´ä¸ªç³»ç»Ÿçš„è¿ä½œæœºåˆ¶ã€‚

## æ¦‚è¿°

`AgentLoop` æ˜¯ nanobot æœ€æ ¸å¿ƒçš„ç»„ä»¶ï¼Œå®ƒå®ç°äº†åŸºäº LLM çš„ **ReAct**ï¼ˆReasoning + Actingï¼‰å¾ªç¯ï¼š

```
ç”¨æˆ·è¾“å…¥ â†’ æ„å»ºä¸Šä¸‹æ–‡ â†’ è°ƒç”¨ LLM â†’ æ‰§è¡Œå·¥å…· â†’ å†æ¬¡è°ƒç”¨ LLM â†’ ... â†’ æœ€ç»ˆå“åº”
```

## æ ¸å¿ƒç±»ï¼šAgentLoop

### ç±»å®šä¹‰

```python
class AgentLoop:
    """
    The agent loop is the core processing engine.
    
    It:
    1. Receives messages from the bus
    2. Builds context with history, memory, skills
    3. Calls the LLM
    4. Executes tool calls
    5. Sends responses back
    """
```

### åˆå§‹åŒ–å‚æ•°

```python
def __init__(
    self,
    bus: MessageBus,              # æ¶ˆæ¯æ€»çº¿
    provider: LLMProvider,        # LLM æä¾›å•†
    workspace: Path,              # å·¥ä½œåŒºè·¯å¾„
    model: str | None = None,     # æ¨¡å‹åç§°
    max_iterations: int = 20,     # æœ€å¤§è¿­ä»£æ¬¡æ•°
    brave_api_key: str | None = None  # Web æœç´¢ API Key
):
```

### æ ¸å¿ƒç»„ä»¶

AgentLoop ç»„åˆäº† 5 ä¸ªå…³é”®ç»„ä»¶ï¼š

```python
self.context = ContextBuilder(workspace)      # ä¸Šä¸‹æ–‡æ„å»ºå™¨
self.sessions = SessionManager(workspace)     # ä¼šè¯ç®¡ç†å™¨
self.tools = ToolRegistry()                   # å·¥å…·æ³¨å†Œè¡¨
self.subagents = SubagentManager(...)         # å­ä»£ç†ç®¡ç†å™¨
self.bus = bus                                # æ¶ˆæ¯æ€»çº¿
```

## ä¸»è¦æ–¹æ³•è¯¦è§£

### 1. å·¥å…·æ³¨å†Œï¼š`_register_default_tools()`

åœ¨åˆå§‹åŒ–æ—¶æ³¨å†Œæ‰€æœ‰é»˜è®¤å·¥å…·ï¼š

```python
def _register_default_tools(self) -> None:
    """Register the default set of tools."""
    # æ–‡ä»¶å·¥å…·
    self.tools.register(ReadFileTool())
    self.tools.register(WriteFileTool())
    self.tools.register(EditFileTool())
    self.tools.register(ListDirTool())
    
    # Shell å·¥å…·
    self.tools.register(ExecTool(working_dir=str(self.workspace)))
    
    # Web å·¥å…·
    self.tools.register(WebSearchTool(api_key=self.brave_api_key))
    self.tools.register(WebFetchTool())
    
    # æ¶ˆæ¯å·¥å…·ï¼ˆå‘é€åˆ°æ¸ é“ï¼‰
    message_tool = MessageTool(send_callback=self.bus.publish_outbound)
    self.tools.register(message_tool)
    
    # å­ä»£ç†ç”Ÿæˆå·¥å…·
    spawn_tool = SpawnTool(manager=self.subagents)
    self.tools.register(spawn_tool)
```

**è®¾è®¡äº®ç‚¹**ï¼š
- æ‰€æœ‰å·¥å…·éƒ½å®ç°äº†ç»Ÿä¸€çš„ `Tool` æ¥å£
- é€šè¿‡æ³¨å†Œè¡¨æ¨¡å¼åŠ¨æ€ç®¡ç†
- æ˜“äºæ‰©å±•æ–°å·¥å…·

### 2. ä¸»å¾ªç¯ï¼š`run()`

è¿™æ˜¯ Agent çš„ä¸»äº‹ä»¶å¾ªç¯ï¼ŒæŒç»­ç›‘å¬æ¶ˆæ¯æ€»çº¿ï¼š

```python
async def run(self) -> None:
    """Run the agent loop, processing messages from the bus."""
    self._running = True
    logger.info("Agent loop started")
    
    while self._running:
        try:
            # ç­‰å¾…ä¸‹ä¸€æ¡æ¶ˆæ¯ï¼ˆè¶…æ—¶ 1 ç§’ï¼‰
            msg = await asyncio.wait_for(
                self.bus.consume_inbound(),
                timeout=1.0
            )
            
            # å¤„ç†æ¶ˆæ¯
            try:
                response = await self._process_message(msg)
                if response:
                    await self.bus.publish_outbound(response)
            except Exception as e:
                logger.error(f"Error processing message: {e}")
                # å‘é€é”™è¯¯å“åº”
                await self.bus.publish_outbound(OutboundMessage(
                    channel=msg.channel,
                    chat_id=msg.chat_id,
                    content=f"Sorry, I encountered an error: {str(e)}"
                ))
        except asyncio.TimeoutError:
            continue  # è¶…æ—¶åç»§ç»­ç­‰å¾…
```

**è®¾è®¡äº®ç‚¹**ï¼š
- ä½¿ç”¨ `asyncio.wait_for` å®ç°è¶…æ—¶æœºåˆ¶
- å¼‚å¸¸æ•è·ç¡®ä¿å•ä¸ªæ¶ˆæ¯å¤±è´¥ä¸ä¼šå¯¼è‡´æ•´ä¸ªå¾ªç¯å´©æºƒ
- é€šè¿‡ `self._running` æ ‡å¿—å®ç°ä¼˜é›…å…³é—­

### 3. æ¶ˆæ¯å¤„ç†ï¼š`_process_message()`

è¿™æ˜¯æœ€æ ¸å¿ƒçš„æ–¹æ³•ï¼Œå®ç°äº†å®Œæ•´çš„ ReAct å¾ªç¯ï¼š

```python
async def _process_message(self, msg: InboundMessage) -> OutboundMessage | None:
    """
    Process a single inbound message.
    """
    # 1. å¤„ç†ç³»ç»Ÿæ¶ˆæ¯ï¼ˆå­ä»£ç†å…¬å‘Šï¼‰
    if msg.channel == "system":
        return await self._process_system_message(msg)
    
    logger.info(f"Processing message from {msg.channel}:{msg.sender_id}")
    
    # 2. è·å–æˆ–åˆ›å»ºä¼šè¯
    session = self.sessions.get_or_create(msg.session_key)
    
    # 3. æ›´æ–°å·¥å…·ä¸Šä¸‹æ–‡ï¼ˆå‘Šè¯‰å·¥å…·å½“å‰çš„ channel å’Œ chat_idï¼‰
    message_tool = self.tools.get("message")
    if isinstance(message_tool, MessageTool):
        message_tool.set_context(msg.channel, msg.chat_id)
    
    spawn_tool = self.tools.get("spawn")
    if isinstance(spawn_tool, SpawnTool):
        spawn_tool.set_context(msg.channel, msg.chat_id)
    
    # 4. æ„å»ºåˆå§‹æ¶ˆæ¯åˆ—è¡¨ï¼ˆåŒ…å«ç³»ç»Ÿæç¤ºã€å†å²ã€å½“å‰æ¶ˆæ¯ï¼‰
    messages = self.context.build_messages(
        history=session.get_history(),
        current_message=msg.content,
        media=msg.media if msg.media else None,
    )
    
    # 5. ReAct å¾ªç¯
    iteration = 0
    final_content = None
    
    while iteration < self.max_iterations:
        iteration += 1
        
        # 5a. è°ƒç”¨ LLM
        response = await self.provider.chat(
            messages=messages,
            tools=self.tools.get_definitions(),
            model=self.model
        )
        
        # 5b. å¤„ç†å·¥å…·è°ƒç”¨
        if response.has_tool_calls:
            # å°† LLM çš„å·¥å…·è°ƒç”¨æ·»åŠ åˆ°æ¶ˆæ¯å†å²
            tool_call_dicts = [
                {
                    "id": tc.id,
                    "type": "function",
                    "function": {
                        "name": tc.name,
                        "arguments": json.dumps(tc.arguments)
                    }
                }
                for tc in response.tool_calls
            ]
            messages = self.context.add_assistant_message(
                messages, response.content, tool_call_dicts
            )
            
            # æ‰§è¡Œæ‰€æœ‰å·¥å…·è°ƒç”¨
            for tool_call in response.tool_calls:
                args_str = json.dumps(tool_call.arguments)
                logger.debug(f"Executing tool: {tool_call.name} with arguments: {args_str}")
                result = await self.tools.execute(tool_call.name, tool_call.arguments)
                
                # å°†å·¥å…·ç»“æœæ·»åŠ åˆ°æ¶ˆæ¯å†å²
                messages = self.context.add_tool_result(
                    messages, tool_call.id, tool_call.name, result
                )
        else:
            # æ²¡æœ‰å·¥å…·è°ƒç”¨ï¼Œå¾—åˆ°æœ€ç»ˆå“åº”
            final_content = response.content
            break
    
    # 6. å¦‚æœè¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°ä»æœªç»“æŸ
    if final_content is None:
        final_content = "I've completed processing but have no response to give."
    
    # 7. ä¿å­˜åˆ°ä¼šè¯å†å²
    session.add_message("user", msg.content)
    session.add_message("assistant", final_content)
    self.sessions.save(session)
    
    # 8. è¿”å›å“åº”
    return OutboundMessage(
        channel=msg.channel,
        chat_id=msg.chat_id,
        content=final_content
    )
```

## ReAct å¾ªç¯è¯¦è§£

è¿™æ˜¯ nanobot çš„æ ¸å¿ƒç®—æ³•ï¼Œè®©æˆ‘ä»¬åˆ†è§£ä¸€ä¸‹ï¼š

### é˜¶æ®µ 1ï¼šä¸Šä¸‹æ–‡æ„å»º

```python
messages = self.context.build_messages(
    history=session.get_history(),
    current_message=msg.content,
)
```

ç”Ÿæˆçš„ `messages` ç»“æ„ï¼š
```json
[
  {
    "role": "system",
    "content": "# nanobot ğŸˆ\nYou are nanobot...\n\n# Memory\n...\n\n# Skills\n..."
  },
  {
    "role": "user",
    "content": "ä¹‹å‰çš„ç”¨æˆ·æ¶ˆæ¯"
  },
  {
    "role": "assistant",
    "content": "ä¹‹å‰çš„åŠ©æ‰‹å›å¤"
  },
  {
    "role": "user",
    "content": "å½“å‰ç”¨æˆ·æ¶ˆæ¯"
  }
]
```

### é˜¶æ®µ 2ï¼šLLM æ¨ç†

```python
response = await self.provider.chat(
    messages=messages,
    tools=self.tools.get_definitions(),
    model=self.model
)
```

LLM å¯èƒ½è¿”å›ï¼š
- **æ–‡æœ¬å“åº”**ï¼šç›´æ¥å›å¤ç”¨æˆ·
- **å·¥å…·è°ƒç”¨**ï¼šéœ€è¦æ‰§è¡ŒæŸäº›æ“ä½œåå†å›å¤

### é˜¶æ®µ 3ï¼šå·¥å…·æ‰§è¡Œ

å¦‚æœ LLM å†³å®šä½¿ç”¨å·¥å…·ï¼š

```python
if response.has_tool_calls:
    for tool_call in response.tool_calls:
        # æ‰§è¡Œå·¥å…·
        result = await self.tools.execute(
            tool_call.name, 
            tool_call.arguments
        )
        
        # å°†ç»“æœæ·»åŠ åˆ°å¯¹è¯å†å²
        messages = self.context.add_tool_result(
            messages, tool_call.id, tool_call.name, result
        )
```

### é˜¶æ®µ 4ï¼šè¿­ä»£æˆ–ç»“æŸ

- **æœ‰å·¥å…·è°ƒç”¨**ï¼šç»§ç»­å¾ªç¯ï¼Œè®© LLM çœ‹åˆ°å·¥å…·ç»“æœåå†æ¬¡æ¨ç†
- **æ— å·¥å…·è°ƒç”¨**ï¼šç»“æŸå¾ªç¯ï¼Œè¿”å›æœ€ç»ˆå“åº”

### å®Œæ•´æµç¨‹ç¤ºä¾‹

ç”¨æˆ·ï¼š**"è¯»å– config.json æ–‡ä»¶çš„å†…å®¹å¹¶æ€»ç»“"**

```
è¿­ä»£ 1:
  LLM â†’ è°ƒç”¨ read_file(path="config.json")
  Tool â†’ è¿”å›æ–‡ä»¶å†…å®¹
  
è¿­ä»£ 2:
  LLM â†’ çœ‹åˆ°æ–‡ä»¶å†…å®¹åï¼Œæ€»ç»“é…ç½®
  è¿”å› â†’ "è¿™ä¸ªé…ç½®æ–‡ä»¶åŒ…å«äº†..."
```

## ç³»ç»Ÿæ¶ˆæ¯å¤„ç†ï¼š`_process_system_message()`

ç”¨äºå¤„ç†å­ä»£ç†çš„å…¬å‘Šæ¶ˆæ¯ï¼š

```python
async def _process_system_message(self, msg: InboundMessage) -> OutboundMessage | None:
    """
    Process a system message (e.g., subagent announce).
    
    The chat_id field contains "original_channel:original_chat_id" to route
    the response back to the correct destination.
    """
    # è§£æåŸå§‹æ¥æº
    if ":" in msg.chat_id:
        parts = msg.chat_id.split(":", 1)
        origin_channel = parts[0]
        origin_chat_id = parts[1]
    else:
        origin_channel = "cli"
        origin_chat_id = msg.chat_id
    
    # ä½¿ç”¨åŸå§‹ä¼šè¯çš„ä¸Šä¸‹æ–‡
    session_key = f"{origin_channel}:{origin_chat_id}"
    session = self.sessions.get_or_create(session_key)
    
    # ... ç±»ä¼¼çš„ ReAct å¾ªç¯ ...
    
    # è·¯ç”±å›åŸå§‹æ¸ é“
    return OutboundMessage(
        channel=origin_channel,
        chat_id=origin_chat_id,
        content=final_content
    )
```

**è®¾è®¡äº®ç‚¹**ï¼š
- å­ä»£ç†å®Œæˆåå¯ä»¥ä¸»åŠ¨é€šçŸ¥ç”¨æˆ·
- é€šè¿‡ `chat_id` ç¼–ç åŸå§‹æ¥æºä¿¡æ¯
- å“åº”ä¼šè·¯ç”±å›æ­£ç¡®çš„æ¸ é“

## ç›´æ¥å¤„ç†ï¼š`process_direct()`

æä¾›åŒæ­¥ API ä¾› CLI ç›´æ¥è°ƒç”¨ï¼š

```python
async def process_direct(self, content: str, session_key: str = "cli:direct") -> str:
    """
    Process a message directly (for CLI usage).
    """
    msg = InboundMessage(
        channel="cli",
        sender_id="user",
        chat_id="direct",
        content=content
    )
    
    response = await self._process_message(msg)
    return response.content if response else ""
```

## å…³é”®è®¾è®¡å†³ç­–

### 1. ä¸ºä»€ä¹ˆä½¿ç”¨è¿­ä»£æ¬¡æ•°é™åˆ¶ï¼Ÿ

```python
max_iterations: int = 20
```

é˜²æ­¢ LLM é™·å…¥æ— é™å¾ªç¯ï¼š
- LLM å¯èƒ½ä¸€ç›´è°ƒç”¨å·¥å…·
- æŸäº›å·¥å…·æ‰§è¡Œå¤±è´¥å LLM å¯èƒ½é‡è¯•
- é™åˆ¶è¿­ä»£æ¬¡æ•°ç¡®ä¿æœ€ç»ˆèƒ½ç»™å‡ºå“åº”

### 2. ä¸ºä»€ä¹ˆå·¥å…·éœ€è¦ `set_context()`ï¼Ÿ

```python
message_tool.set_context(msg.channel, msg.chat_id)
spawn_tool.set_context(msg.channel, msg.chat_id)
```

æŸäº›å·¥å…·éœ€è¦çŸ¥é“å½“å‰å¯¹è¯çš„æ¥æºï¼š
- `message` å·¥å…·éœ€è¦çŸ¥é“å¾€å“ªä¸ªæ¸ é“å‘é€æ¶ˆæ¯
- `spawn` å·¥å…·éœ€è¦çŸ¥é“å­ä»£ç†å®Œæˆåé€šçŸ¥è°

### 3. ä¸ºä»€ä¹ˆè¦ä¿å­˜ä¼šè¯å†å²ï¼Ÿ

```python
session.add_message("user", msg.content)
session.add_message("assistant", final_content)
self.sessions.save(session)
```

- å¤šè½®å¯¹è¯éœ€è¦ä¸Šä¸‹æ–‡
- ç”¨æˆ·å¯èƒ½å¼•ç”¨ä¹‹å‰çš„å†…å®¹
- æŒä¹…åŒ–åˆ°ç£ç›˜é¿å…é‡å¯åä¸¢å¤±

## æ€§èƒ½ä¼˜åŒ–

### 1. å¼‚æ­¥æ‰§è¡Œ

æ‰€æœ‰ I/O æ“ä½œéƒ½æ˜¯å¼‚æ­¥çš„ï¼š
```python
await self.provider.chat(...)       # ç½‘ç»œè¯·æ±‚
await self.tools.execute(...)       # å¯èƒ½çš„æ–‡ä»¶/ç½‘ç»œæ“ä½œ
await self.bus.publish_outbound(...) # é˜Ÿåˆ—æ“ä½œ
```

### 2. è¶…æ—¶æœºåˆ¶

é¿å…é•¿æ—¶é—´é˜»å¡ï¼š
```python
msg = await asyncio.wait_for(
    self.bus.consume_inbound(),
    timeout=1.0
)
```

### 3. å¹¶å‘å¤„ç†

ä¸»å¾ªç¯å¯ä»¥ä¸å…¶ä»–æœåŠ¡å¹¶å‘è¿è¡Œï¼š
```python
await asyncio.gather(
    agent.run(),              # Agent å¾ªç¯
    bus.dispatch_outbound(),  # æ¶ˆæ¯åˆ†å‘
    channel_manager.start(),  # æ¸ é“ç›‘å¬
)
```

## é”™è¯¯å¤„ç†

### 1. æ¶ˆæ¯å¤„ç†é”™è¯¯

```python
try:
    response = await self._process_message(msg)
    await self.bus.publish_outbound(response)
except Exception as e:
    logger.error(f"Error processing message: {e}")
    # å‘é€å‹å¥½çš„é”™è¯¯æ¶ˆæ¯ç»™ç”¨æˆ·
    await self.bus.publish_outbound(OutboundMessage(
        channel=msg.channel,
        chat_id=msg.chat_id,
        content=f"Sorry, I encountered an error: {str(e)}"
    ))
```

### 2. LLM è°ƒç”¨é”™è¯¯

åœ¨ `LiteLLMProvider` ä¸­å¤„ç†ï¼š
```python
try:
    response = await acompletion(**kwargs)
    return self._parse_response(response)
except Exception as e:
    return LLMResponse(
        content=f"Error calling LLM: {str(e)}",
        finish_reason="error",
    )
```

## æ‰©å±•ç‚¹

### 1. è‡ªå®šä¹‰å·¥å…·

ç»§æ‰¿ `Tool` åŸºç±»å¹¶æ³¨å†Œï¼š
```python
class MyCustomTool(Tool):
    @property
    def name(self) -> str:
        return "my_tool"
    
    async def execute(self, **kwargs) -> str:
        # å®ç°ä½ çš„é€»è¾‘
        return "result"

# æ³¨å†Œ
agent.tools.register(MyCustomTool())
```

### 2. è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†

å¯ä»¥ç»§æ‰¿ `AgentLoop` å¹¶è¦†ç›– `_process_message()`ï¼š
```python
class CustomAgentLoop(AgentLoop):
    async def _process_message(self, msg: InboundMessage):
        # æ·»åŠ è‡ªå®šä¹‰é€»è¾‘
        if msg.content.startswith("/custom"):
            return OutboundMessage(...)
        
        # è°ƒç”¨çˆ¶ç±»æ–¹æ³•
        return await super()._process_message(msg)
```

## è°ƒè¯•æŠ€å·§

### 1. æŸ¥çœ‹å®Œæ•´çš„æ¶ˆæ¯æµ

åœ¨å…³é”®ä½ç½®æ·»åŠ æ—¥å¿—ï¼š
```python
logger.debug(f"Messages before LLM call: {json.dumps(messages, indent=2)}")
logger.debug(f"LLM response: {response}")
logger.debug(f"Tool result: {result}")
```

### 2. æ£€æŸ¥å·¥å…·å®šä¹‰

```python
tools = agent.tools.get_definitions()
print(json.dumps(tools, indent=2))
```

### 3. æŸ¥çœ‹ä¼šè¯å†å²

```python
session = agent.sessions.get_or_create("cli:default")
print(session.get_history())
```

## å°ç»“

é€šè¿‡æœ¬ç« ï¼Œä½ åº”è¯¥æŒæ¡äº†ï¼š
- âœ… AgentLoop çš„æ ¸å¿ƒç»“æ„å’ŒèŒè´£
- âœ… ReAct å¾ªç¯çš„å®Œæ•´æµç¨‹
- âœ… å·¥å…·æ³¨å†Œå’Œæ‰§è¡Œæœºåˆ¶
- âœ… ä¼šè¯ç®¡ç†å’Œæ¶ˆæ¯è·¯ç”±
- âœ… é”™è¯¯å¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–

**å…³é”®è¦ç‚¹**ï¼š
- AgentLoop æ˜¯æ•´ä¸ªç³»ç»Ÿçš„å¤§è„‘
- ReAct å¾ªç¯æ˜¯æ ¸å¿ƒç®—æ³•ï¼ˆæ¨ç† â†’ è¡ŒåŠ¨ â†’ æ¨ç†...ï¼‰
- å·¥å…·æ˜¯ Agent ä¸å¤–ç•Œäº¤äº’çš„å”¯ä¸€æ–¹å¼
- å¼‚æ­¥è®¾è®¡ç¡®ä¿é«˜æ€§èƒ½

**ä¸‹ä¸€æ­¥**ï¼š[06-ä¸Šä¸‹æ–‡æ„å»º.md](./nanobot/2026-02-03/06-ä¸Šä¸‹æ–‡æ„å»º.md) - äº†è§£å¦‚ä½•ç»„è£… Promptã€‚
