# ç¬¬å››å±‚ï¼šå†…ç½®å·¥å…·è¯¦è§£

> ğŸ“Œ **æ ¸å¿ƒæ–‡ä»¶**ï¼š`nanobot/agent/tools/*.py`

## æ¦‚è¿°

nanobot å†…ç½®äº† 9 ä¸ªæ ¸å¿ƒå·¥å…·ï¼Œæ¶µç›–æ–‡ä»¶ç³»ç»Ÿã€Shell æ‰§è¡Œã€Web æ“ä½œã€æ¶ˆæ¯å‘é€å’Œå­ä»£ç†ç®¡ç†ã€‚æœ¬ç« è¯¦ç»†ä»‹ç»æ¯ä¸ªå·¥å…·çš„åŠŸèƒ½ã€å‚æ•°å’Œä½¿ç”¨æ–¹å¼ã€‚

## æ–‡ä»¶ç³»ç»Ÿå·¥å…·

### 1. ReadFileTool - è¯»å–æ–‡ä»¶

**åŠŸèƒ½**ï¼šè¯»å–æ–‡ä»¶å†…å®¹

**å‚æ•°**ï¼š
```json
{
  "path": "æ–‡ä»¶è·¯å¾„ï¼ˆæ”¯æŒ ~ å±•å¼€ï¼‰"
}
```

**å®ç°**ï¼š
```python
class ReadFileTool(Tool):
    async def execute(self, path: str) -> str:
        try:
            file_path = Path(path).expanduser()
            if not file_path.exists():
                return f"Error: File not found: {path}"
            if not file_path.is_file():
                return f"Error: Not a file: {path}"
            
            content = file_path.read_text(encoding="utf-8")
            return content
        except PermissionError:
            return f"Error: Permission denied: {path}"
        except Exception as e:
            return f"Error reading file: {str(e)}"
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

ç”¨æˆ·ï¼š**"è¯»å– README.md æ–‡ä»¶"**

LLM è°ƒç”¨ï¼š
```json
{
  "name": "read_file",
  "arguments": {"path": "README.md"}
}
```

è¿”å›ï¼š
```
# nanobot

nanobot is an ultra-lightweight personal AI assistant...
```

**ç‰¹ç‚¹**ï¼š
- æ”¯æŒ `~` è·¯å¾„è‡ªåŠ¨å±•å¼€
- UTF-8 ç¼–ç 
- å®Œå–„çš„é”™è¯¯å¤„ç†ï¼ˆæ–‡ä»¶ä¸å­˜åœ¨ã€æƒé™ä¸è¶³ç­‰ï¼‰

### 2. WriteFileTool - å†™å…¥æ–‡ä»¶

**åŠŸèƒ½**ï¼šå†™å…¥æ–‡ä»¶å†…å®¹ï¼Œè‡ªåŠ¨åˆ›å»ºçˆ¶ç›®å½•

**å‚æ•°**ï¼š
```json
{
  "path": "æ–‡ä»¶è·¯å¾„",
  "content": "è¦å†™å…¥çš„å†…å®¹"
}
```

**å®ç°**ï¼š
```python
class WriteFileTool(Tool):
    async def execute(self, path: str, content: str) -> str:
        try:
            file_path = Path(path).expanduser()
            # è‡ªåŠ¨åˆ›å»ºçˆ¶ç›®å½•
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file_path.write_text(content, encoding="utf-8")
            return f"Successfully wrote {len(content)} bytes to {path}"
        except PermissionError:
            return f"Error: Permission denied: {path}"
        except Exception as e:
            return f"Error writing file: {str(e)}"
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

ç”¨æˆ·ï¼š**"åˆ›å»ºä¸€ä¸ª hello.txt æ–‡ä»¶ï¼Œå†…å®¹æ˜¯ 'Hello, World!'"**

LLM è°ƒç”¨ï¼š
```json
{
  "name": "write_file",
  "arguments": {
    "path": "hello.txt",
    "content": "Hello, World!"
  }
}
```

è¿”å›ï¼š
```
Successfully wrote 13 bytes to hello.txt
```

**ç‰¹ç‚¹**ï¼š
- è‡ªåŠ¨åˆ›å»ºä¸å­˜åœ¨çš„çˆ¶ç›®å½•
- è¦†ç›–å·²æœ‰æ–‡ä»¶
- è¿”å›å†™å…¥çš„å­—èŠ‚æ•°

### 3. EditFileTool - ç¼–è¾‘æ–‡ä»¶

**åŠŸèƒ½**ï¼šé€šè¿‡æ–‡æœ¬æ›¿æ¢ç¼–è¾‘æ–‡ä»¶

**å‚æ•°**ï¼š
```json
{
  "path": "æ–‡ä»¶è·¯å¾„",
  "old_text": "è¦æ›¿æ¢çš„ç¡®åˆ‡æ–‡æœ¬",
  "new_text": "æ–°æ–‡æœ¬"
}
```

**å®ç°**ï¼š
```python
class EditFileTool(Tool):
    async def execute(self, path: str, old_text: str, new_text: str) -> str:
        try:
            file_path = Path(path).expanduser()
            if not file_path.exists():
                return f"Error: File not found: {path}"
            
            content = file_path.read_text(encoding="utf-8")
            
            if old_text not in content:
                return f"Error: old_text not found in file. Make sure it matches exactly."
            
            # æ£€æŸ¥å”¯ä¸€æ€§
            count = content.count(old_text)
            if count > 1:
                return f"Warning: old_text appears {count} times. Please provide more context to make it unique."
            
            new_content = content.replace(old_text, new_text, 1)
            file_path.write_text(new_content, encoding="utf-8")
            
            return f"Successfully edited {path}"
        except Exception as e:
            return f"Error editing file: {str(e)}"
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

ç”¨æˆ·ï¼š**"å°† config.json ä¸­çš„ç«¯å£ä» 8000 æ”¹ä¸º 9000"**

LLM å…ˆè¯»å–æ–‡ä»¶ï¼Œç„¶åè°ƒç”¨ï¼š
```json
{
  "name": "edit_file",
  "arguments": {
    "path": "config.json",
    "old_text": "\"port\": 8000",
    "new_text": "\"port\": 9000"
  }
}
```

**ç‰¹ç‚¹**ï¼š
- ç²¾ç¡®æ–‡æœ¬åŒ¹é…
- æ£€æŸ¥å”¯ä¸€æ€§ï¼ˆé¿å…è¯¯æ›¿æ¢ï¼‰
- åªæ›¿æ¢ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹

### 4. ListDirTool - åˆ—å‡ºç›®å½•

**åŠŸèƒ½**ï¼šåˆ—å‡ºç›®å½•å†…å®¹

**å‚æ•°**ï¼š
```json
{
  "path": "ç›®å½•è·¯å¾„"
}
```

**å®ç°**ï¼š
```python
class ListDirTool(Tool):
    async def execute(self, path: str) -> str:
        try:
            dir_path = Path(path).expanduser()
            if not dir_path.exists():
                return f"Error: Directory not found: {path}"
            if not dir_path.is_dir():
                return f"Error: Not a directory: {path}"
            
            items = []
            for item in sorted(dir_path.iterdir()):
                prefix = "ğŸ“ " if item.is_dir() else "ğŸ“„ "
                items.append(f"{prefix}{item.name}")
            
            if not items:
                return f"Directory {path} is empty"
            
            return "\n".join(items)
        except Exception as e:
            return f"Error listing directory: {str(e)}"
```

**è¿”å›ç¤ºä¾‹**ï¼š
```
ğŸ“ nanobot
ğŸ“ docs
ğŸ“„ README.md
ğŸ“„ pyproject.toml
ğŸ“„ LICENSE
```

## Shell å·¥å…·

### 5. ExecTool - æ‰§è¡Œå‘½ä»¤

**åŠŸèƒ½**ï¼šæ‰§è¡Œ Shell å‘½ä»¤

**å‚æ•°**ï¼š
```json
{
  "command": "è¦æ‰§è¡Œçš„å‘½ä»¤"
}
```

**å®ç°**ï¼š
```python
class ExecTool(Tool):
    def __init__(self, working_dir: str = "."):
        self.working_dir = working_dir
    
    async def execute(self, command: str) -> str:
        try:
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=self.working_dir
            )
            
            stdout, stderr = await process.communicate()
            
            result_parts = []
            if stdout:
                result_parts.append(f"stdout:\n{stdout.decode()}")
            if stderr:
                result_parts.append(f"stderr:\n{stderr.decode()}")
            if process.returncode != 0:
                result_parts.append(f"exit code: {process.returncode}")
            
            return "\n".join(result_parts) if result_parts else "Command executed successfully (no output)"
        except Exception as e:
            return f"Error executing command: {str(e)}"
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

ç”¨æˆ·ï¼š**"ç»Ÿè®¡å½“å‰ç›®å½•çš„ Python æ–‡ä»¶æ•°é‡"**

LLM è°ƒç”¨ï¼š
```json
{
  "name": "exec",
  "arguments": {"command": "find . -name '*.py' | wc -l"}
}
```

è¿”å›ï¼š
```
stdout:
42
```

**å®‰å…¨æ³¨æ„**ï¼š
- âš ï¸ å¯ä»¥æ‰§è¡Œä»»æ„å‘½ä»¤ï¼Œæœ‰å®‰å…¨é£é™©
- å»ºè®®åœ¨å—ä¿¡ä»»ç¯å¢ƒä¸­ä½¿ç”¨
- å¯ä»¥è€ƒè™‘æ·»åŠ å‘½ä»¤ç™½åå•

## Web å·¥å…·

### 6. WebSearchTool - Web æœç´¢

**åŠŸèƒ½**ï¼šä½¿ç”¨ Brave Search API æœç´¢ç½‘é¡µ

**å‚æ•°**ï¼š
```json
{
  "query": "æœç´¢å…³é”®è¯",
  "count": 5  // å¯é€‰ï¼Œé»˜è®¤ 5 æ¡ç»“æœ
}
```

**å®ç°**ï¼š
```python
class WebSearchTool(Tool):
    def __init__(self, api_key: str | None = None):
        self.api_key = api_key
    
    async def execute(self, query: str, count: int = 5) -> str:
        if not self.api_key:
            return "Web search not configured (missing API key)"
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://api.search.brave.com/res/v1/web/search",
                    headers={"X-Subscription-Token": self.api_key},
                    params={"q": query, "count": count}
                )
                response.raise_for_status()
                
                data = response.json()
                results = data.get("web", {}).get("results", [])
                
                formatted = []
                for i, result in enumerate(results, 1):
                    formatted.append(
                        f"{i}. {result['title']}\n"
                        f"   {result['url']}\n"
                        f"   {result['description']}"
                    )
                
                return "Search results:\n\n" + "\n\n".join(formatted)
        except Exception as e:
            return f"Error searching web: {str(e)}"
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

ç”¨æˆ·ï¼š**"æœç´¢ä¸€ä¸‹ nanobot AI çš„ç›¸å…³ä¿¡æ¯"**

LLM è°ƒç”¨ï¼š
```json
{
  "name": "web_search",
  "arguments": {"query": "nanobot AI assistant", "count": 3}
}
```

### 7. WebFetchTool - æŠ“å–ç½‘é¡µ

**åŠŸèƒ½**ï¼šæŠ“å–å¹¶æå–ç½‘é¡µä¸»è¦å†…å®¹

**å‚æ•°**ï¼š
```json
{
  "url": "ç½‘é¡µ URL"
}
```

**å®ç°**ï¼š
```python
from readability import Document

class WebFetchTool(Tool):
    async def execute(self, url: str) -> str:
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(url, timeout=10.0)
                response.raise_for_status()
                
                # ä½¿ç”¨ readability æå–ä¸»è¦å†…å®¹
                doc = Document(response.text)
                title = doc.title()
                content = doc.summary()
                
                # ç®€å•çš„ HTML è½¬æ–‡æœ¬
                import re
                text = re.sub('<[^<]+?>', '', content)
                text = re.sub(r'\n\s*\n', '\n\n', text)
                
                return f"Page: {title}\n\n{text[:2000]}"
        except Exception as e:
            return f"Error fetching URL: {str(e)}"
```

**ç‰¹ç‚¹**ï¼š
- ä½¿ç”¨ `readability-lxml` æå–ä¸»è¦å†…å®¹
- è‡ªåŠ¨è¿‡æ»¤å¹¿å‘Šå’Œå¯¼èˆªç­‰å™ªéŸ³
- é™åˆ¶è¿”å›é•¿åº¦é¿å…è¶…è¿‡ä¸Šä¸‹æ–‡çª—å£

## æ¶ˆæ¯å·¥å…·

### 8. MessageTool - å‘é€æ¶ˆæ¯

**åŠŸèƒ½**ï¼šå‘é€æ¶ˆæ¯åˆ°ç‰¹å®šæ¸ é“

**å‚æ•°**ï¼š
```json
{
  "content": "æ¶ˆæ¯å†…å®¹",
  "to": "æ¥æ”¶è€… IDï¼ˆå¯é€‰ï¼‰"
}
```

**å®ç°**ï¼š
```python
class MessageTool(Tool):
    def __init__(self, send_callback):
        self.send_callback = send_callback
        self._channel = None
        self._chat_id = None
    
    def set_context(self, channel: str, chat_id: str):
        """è®¾ç½®å½“å‰å¯¹è¯ä¸Šä¸‹æ–‡"""
        self._channel = channel
        self._chat_id = chat_id
    
    async def execute(self, content: str, to: str | None = None) -> str:
        target_chat_id = to or self._chat_id
        
        if not target_chat_id:
            return "Error: No recipient specified"
        
        await self.send_callback(OutboundMessage(
            channel=self._channel,
            chat_id=target_chat_id,
            content=content
        ))
        
        return f"Message sent to {target_chat_id}"
```

**ä½¿ç”¨åœºæ™¯**ï¼š
- å®šæ—¶ä»»åŠ¡çš„é€šçŸ¥
- å­ä»£ç†å®Œæˆåçš„ä¸»åŠ¨æ¶ˆæ¯
- å‘ç‰¹å®šç”¨æˆ·å‘é€æé†’

**æ³¨æ„**ï¼š
- æ™®é€šå¯¹è¯ä¸éœ€è¦ä½¿ç”¨æ­¤å·¥å…·ï¼Œç›´æ¥å›å¤å³å¯
- åªåœ¨éœ€è¦ä¸»åŠ¨å‘é€æ¶ˆæ¯æ—¶ä½¿ç”¨

## å­ä»£ç†å·¥å…·

### 9. SpawnTool - ç”Ÿæˆå­ä»£ç†

**åŠŸèƒ½**ï¼šåˆ›å»ºåå°å­ä»£ç†å¤„ç†é•¿æ—¶é—´ä»»åŠ¡

**å‚æ•°**ï¼š
```json
{
  "task": "ä»»åŠ¡æè¿°",
  "announce": true  // æ˜¯å¦åœ¨å®Œæˆåé€šçŸ¥
}
```

**å®ç°**ï¼š
```python
class SpawnTool(Tool):
    def __init__(self, manager: SubagentManager):
        self.manager = manager
        self._channel = None
        self._chat_id = None
    
    def set_context(self, channel: str, chat_id: str):
        self._channel = channel
        self._chat_id = chat_id
    
    async def execute(self, task: str, announce: bool = True) -> str:
        origin = f"{self._channel}:{self._chat_id}"
        
        subagent_id = await self.manager.spawn(
            task=task,
            origin=origin,
            announce=announce
        )
        
        return f"Spawned subagent {subagent_id} to handle: {task}"
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

ç”¨æˆ·ï¼š**"æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡ç½‘ç«™çŠ¶æ€"**

LLM è°ƒç”¨ï¼š
```json
{
  "name": "spawn",
  "arguments": {
    "task": "æ¯å°æ—¶è®¿é—® https://example.com å¹¶æ£€æŸ¥æ˜¯å¦åœ¨çº¿ï¼Œå¦‚æœç¦»çº¿åˆ™é€šçŸ¥ç”¨æˆ·",
    "announce": true
  }
}
```

å­ä»£ç†åœ¨åå°è¿è¡Œï¼Œå‘ç°é—®é¢˜æ—¶ä¼šä¸»åŠ¨é€šçŸ¥ã€‚

## å·¥å…·ä½¿ç”¨æœ€ä½³å®è·µ

### 1. ç»„åˆä½¿ç”¨å·¥å…·

LLM å¯ä»¥æ™ºèƒ½ç»„åˆå¤šä¸ªå·¥å…·ï¼š

**ç”¨æˆ·**ï¼š**"æ‰¾å‡ºé¡¹ç›®ä¸­æ‰€æœ‰ TODO æ³¨é‡Š"**

```
ç¬¬ 1 è½®ï¼š
  LLM â†’ list_dir(path=".")
  ç»“æœï¼š[æ–‡ä»¶åˆ—è¡¨]

ç¬¬ 2 è½®ï¼š
  LLM â†’ exec(command="grep -r 'TODO' *.py")
  ç»“æœï¼š[TODO åˆ—è¡¨]

ç¬¬ 3 è½®ï¼š
  LLM â†’ æ€»ç»“ï¼š"æ‰¾åˆ° 5 ä¸ª TODO..."
```

### 2. é”™è¯¯æ¢å¤

å·¥å…·å¤±è´¥æ—¶ï¼ŒLLM ä¼šå°è¯•å…¶ä»–æ–¹æ³•ï¼š

```
å°è¯• 1ï¼šread_file("~/config.json")
å¤±è´¥ï¼šPermission denied

å°è¯• 2ï¼šexec("cat ~/config.json")
æˆåŠŸï¼šè¿”å›å†…å®¹
```

### 3. æ¸è¿›å¼æ“ä½œ

```
ç”¨æˆ·ï¼š"å¤‡ä»½æ‰€æœ‰é…ç½®æ–‡ä»¶"

ç¬¬ 1 æ­¥ï¼šlist_diræŸ¥æ‰¾é…ç½®æ–‡ä»¶
ç¬¬ 2 æ­¥ï¼šé€ä¸ª read_file
ç¬¬ 3 æ­¥ï¼šwrite_file åˆ°å¤‡ä»½ç›®å½•
ç¬¬ 4 æ­¥ï¼šæŠ¥å‘Šå®Œæˆ
```

## å·¥å…·æ‰§è¡Œæµç¨‹

å®Œæ•´çš„å·¥å…·è°ƒç”¨æµç¨‹ï¼š

```mermaid
sequenceDiagram
    participant User
    participant Agent
    participant LLM
    participant Tool

    User->>Agent: "è¯»å– config.json"
    Agent->>LLM: å‘é€æ¶ˆæ¯ + å·¥å…·åˆ—è¡¨
    LLM->>Agent: è¿”å›å·¥å…·è°ƒç”¨
    Note over LLM,Agent: {name: "read_file", arguments: {...}}
    Agent->>Tool: execute(path="config.json")
    Tool->>Agent: è¿”å›æ–‡ä»¶å†…å®¹
    Agent->>LLM: å‘é€å·¥å…·ç»“æœ
    LLM->>Agent: ç”Ÿæˆæœ€ç»ˆå“åº”
    Agent->>User: "æ–‡ä»¶å†…å®¹æ˜¯..."
```

## æ€§èƒ½ä¼˜åŒ–

### 1. å¹¶å‘æ‰§è¡Œï¼ˆæœªæ¥ä¼˜åŒ–ï¼‰

ç°åœ¨å·¥å…·æ˜¯ä¸²è¡Œæ‰§è¡Œçš„ï¼Œå¯ä»¥æ”¹ä¸ºå¹¶å‘ï¼š

```python
# å½“å‰ï¼šä¸²è¡Œ
for tool_call in response.tool_calls:
    result = await self.tools.execute(tool_call.name, tool_call.arguments)

# ä¼˜åŒ–ï¼šå¹¶å‘
tasks = [
    self.tools.execute(tc.name, tc.arguments)
    for tc in response.tool_calls
]
results = await asyncio.gather(*tasks)
```

### 2. ç¼“å­˜ç»“æœ

```python
class CachedWebFetchTool(WebFetchTool):
    def __init__(self):
        super().__init__()
        self._cache = {}
    
    async def execute(self, url: str) -> str:
        if url in self._cache:
            return self._cache[url]
        
        result = await super().execute(url)
        self._cache[url] = result
        return result
```

## å°ç»“

é€šè¿‡æœ¬ç« ï¼Œä½ åº”è¯¥æŒæ¡äº†ï¼š
- âœ… æ‰€æœ‰ 9 ä¸ªå†…ç½®å·¥å…·çš„åŠŸèƒ½å’Œç”¨æ³•
- âœ… å·¥å…·çš„å‚æ•°æ ¼å¼å’Œè¿”å›å€¼
- âœ… å·¥å…·ç»„åˆä½¿ç”¨çš„æ¨¡å¼
- âœ… é”™è¯¯å¤„ç†å’Œæœ€ä½³å®è·µ

**ä¸‹ä¸€æ­¥**ï¼š[10-æŠ€èƒ½ç³»ç»Ÿ.md](./nanobot/2026-02-03/10-æŠ€èƒ½ç³»ç»Ÿ.md) - äº†è§£æ›´çµæ´»çš„æŠ€èƒ½æœºåˆ¶ã€‚
