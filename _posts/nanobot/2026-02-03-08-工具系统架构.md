# ç¬¬å››å±‚ï¼šå·¥å…·ç³»ç»Ÿæ¶æ„

> ğŸ“Œ **æ ¸å¿ƒæ–‡ä»¶**ï¼š  
> - `nanobot/agent/tools/base.py` - å·¥å…·åŸºç±»  
> - `nanobot/agent/tools/registry.py` - å·¥å…·æ³¨å†Œè¡¨  
> - `nanobot/agent/tools/*.py` - å„ç§å†…ç½®å·¥å…·

## æ¦‚è¿°

å·¥å…·ï¼ˆToolï¼‰æ˜¯ Agent ä¸å¤–éƒ¨ä¸–ç•Œäº¤äº’çš„**å”¯ä¸€æ–¹å¼**ã€‚é€šè¿‡å·¥å…·ï¼ŒLLM å¯ä»¥ï¼š
- ğŸ“ è¯»å†™æ–‡ä»¶
- ğŸš æ‰§è¡Œ Shell å‘½ä»¤
- ğŸŒ æœç´¢å’ŒæŠ“å–ç½‘é¡µ
- ğŸ’¬ å‘é€æ¶ˆæ¯åˆ°èŠå¤©æ¸ é“
- ğŸ¤– ç”Ÿæˆå­ä»£ç†å¤„ç†å¤æ‚ä»»åŠ¡

## å·¥å…·çš„æŠ½è±¡è®¾è®¡

### 1. åŸºç±»ï¼š`Tool` (ABC)

æ‰€æœ‰å·¥å…·éƒ½ç»§æ‰¿è‡ªè¿™ä¸ªæŠ½è±¡åŸºç±»ï¼š

```python
from abc import ABC, abstractmethod
from typing import Any

class Tool(ABC):
    """
    Abstract base class for agent tools.
    
    Tools are capabilities that the agent can use to interact with
    the environment, such as reading files, executing commands, etc.
    """
    
    @property
    @abstractmethod
    def name(self) -> str:
        """Tool name used in function calls."""
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        """Description of what the tool does."""
        pass
    
    @property
    @abstractmethod
    def parameters(self) -> dict[str, Any]:
        """JSON Schema for tool parameters."""
        pass
    
    @abstractmethod
    async def execute(self, **kwargs: Any) -> str:
        """
        Execute the tool with given parameters.
        
        Args:
            **kwargs: Tool-specific parameters.
        
        Returns:
            String result of the tool execution.
        """
        pass
    
    def to_schema(self) -> dict[str, Any]:
        """Convert tool to OpenAI function schema format."""
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": self.parameters,
            }
        }
```

**è®¾è®¡äº®ç‚¹**ï¼š
- ä½¿ç”¨ ABCï¼ˆæŠ½è±¡åŸºç±»ï¼‰å¼ºåˆ¶å­ç±»å®ç°å¿…è¦æ–¹æ³•
- `to_schema()` è‡ªåŠ¨ç”Ÿæˆ OpenAI Function Calling æ ¼å¼
- `execute()` è¿”å›å­—ç¬¦ä¸²ï¼Œç®€åŒ– LLM çš„ç†è§£

### 2. å·¥å…·æ³¨å†Œè¡¨ï¼š`ToolRegistry`

ç®¡ç†æ‰€æœ‰å·¥å…·çš„æ³¨å†Œã€æŸ¥æ‰¾å’Œæ‰§è¡Œï¼š

```python
class ToolRegistry:
    """Registry for managing agent tools."""
    
    def __init__(self):
        self._tools: dict[str, Tool] = {}
    
    def register(self, tool: Tool) -> None:
        """Register a new tool."""
        self._tools[tool.name] = tool
        logger.debug(f"Registered tool: {tool.name}")
    
    def get(self, name: str) -> Tool | None:
        """Get a tool by name."""
        return self._tools.get(name)
    
    def get_definitions(self) -> list[dict[str, Any]]:
        """Get all tool definitions for LLM function calling."""
        return [tool.to_schema() for tool in self._tools.values()]
    
    async def execute(self, name: str, arguments: dict[str, Any]) -> str:
        """Execute a tool by name with given arguments."""
        tool = self.get(name)
        if not tool:
            return f"Error: Tool '{name}' not found"
        
        try:
            result = await tool.execute(**arguments)
            return result
        except Exception as e:
            logger.error(f"Tool {name} execution error: {e}")
            return f"Error executing {name}: {str(e)}"
```

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
1. **æ³¨å†Œ**ï¼š`register(tool)` - æ·»åŠ æ–°å·¥å…·
2. **æŸ¥æ‰¾**ï¼š`get(name)` - æŒ‰åç§°è·å–å·¥å…·
3. **å®šä¹‰**ï¼š`get_definitions()` - ç”Ÿæˆ LLM èƒ½ç†è§£çš„å·¥å…·åˆ—è¡¨
4. **æ‰§è¡Œ**ï¼š`execute(name, args)` - è°ƒç”¨å·¥å…·å¹¶æ•è·å¼‚å¸¸

## å†…ç½®å·¥å…·è¯¦è§£

### 1. æ–‡ä»¶ç³»ç»Ÿå·¥å…·

#### `ReadFileTool` - è¯»å–æ–‡ä»¶

```python
class ReadFileTool(Tool):
    @property
    def name(self) -> str:
        return "read_file"
    
    @property
    def description(self) -> str:
        return "Read the contents of a file"
    
    @property
    def parameters(self) -> dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "Path to the file to read"
                }
            },
            "required": ["path"]
        }
    
    async def execute(self, path: str) -> str:
        try:
            file_path = Path(path).expanduser()
            content = file_path.read_text(encoding="utf-8")
            return f"File content of {path}:\n\n{content}"
        except Exception as e:
            return f"Error reading file: {str(e)}"
```

**LLM ä¼šçœ‹åˆ°çš„å·¥å…·å®šä¹‰**ï¼š
```json
{
  "type": "function",
  "function": {
    "name": "read_file",
    "description": "Read the contents of a file",
    "parameters": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "Path to the file to read"
        }
      },
      "required": ["path"]
    }
  }
}
```

#### `WriteFileTool` - å†™å…¥æ–‡ä»¶

```python
async def execute(self, path: str, content: str) -> str:
    try:
        file_path = Path(path).expanduser()
        file_path.parent.mkdir(parents=True, exist_ok=True)
        file_path.write_text(content, encoding="utf-8")
        return f"Successfully wrote to {path}"
    except Exception as e:
        return f"Error writing file: {str(e)}"
```

**ç‰¹æ€§**ï¼š
- è‡ªåŠ¨åˆ›å»ºçˆ¶ç›®å½•
- UTF-8 ç¼–ç 
- é”™è¯¯å¤„ç†

#### `EditFileTool` - ç¼–è¾‘æ–‡ä»¶

æ”¯æŒè¡Œå·èŒƒå›´ç¼–è¾‘ï¼š

```python
async def execute(
    self, 
    path: str, 
    start_line: int, 
    end_line: int, 
    new_content: str
) -> str:
    try:
        file_path = Path(path).expanduser()
        lines = file_path.read_text(encoding="utf-8").splitlines()
        
        # æ›¿æ¢æŒ‡å®šè¡Œ
        new_lines = (
            lines[:start_line-1] + 
            new_content.splitlines() + 
            lines[end_line:]
        )
        
        file_path.write_text("\n".join(new_lines), encoding="utf-8")
        return f"Successfully edited {path} (lines {start_line}-{end_line})"
    except Exception as e:
        return f"Error editing file: {str(e)}"
```

#### `ListDirTool` - åˆ—å‡ºç›®å½•

```python
async def execute(self, path: str = ".") -> str:
    try:
        dir_path = Path(path).expanduser()
        items = []
        for item in sorted(dir_path.iterdir()):
            prefix = "ğŸ“" if item.is_dir() else "ğŸ“„"
            items.append(f"{prefix} {item.name}")
        
        return f"Contents of {path}:\n" + "\n".join(items)
    except Exception as e:
        return f"Error listing directory: {str(e)}"
```

### 2. Shell å·¥å…·

#### `ExecTool` - æ‰§è¡Œå‘½ä»¤

```python
class ExecTool(Tool):
    def __init__(self, working_dir: str = "."):
        self.working_dir = working_dir
    
    @property
    def name(self) -> str:
        return "exec"
    
    @property
    def description(self) -> str:
        return "Execute a shell command and return its output"
    
    @property
    def parameters(self) -> dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "description": "The shell command to execute"
                }
            },
            "required": ["command"]
        }
    
    async def execute(self, command: str) -> str:
        try:
            # ä½¿ç”¨ asyncio.create_subprocess_shell
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=self.working_dir
            )
            
            stdout, stderr = await process.communicate()
            
            result_parts = []
            if stdout:
                result_parts.append(f"stdout:\n{stdout.decode()}")
            if stderr:
                result_parts.append(f"stderr:\n{stderr.decode()}")
            if process.returncode != 0:
                result_parts.append(f"exit code: {process.returncode}")
            
            return "\n".join(result_parts) if result_parts else "Command executed successfully (no output)"
        except Exception as e:
            return f"Error executing command: {str(e)}"
```

**å®‰å…¨æ³¨æ„äº‹é¡¹**ï¼š
- âš ï¸ ç›´æ¥æ‰§è¡Œ shell å‘½ä»¤æœ‰å®‰å…¨é£é™©
- å»ºè®®åœ¨å—æ§ç¯å¢ƒä¸­ä½¿ç”¨
- å¯ä»¥æ·»åŠ å‘½ä»¤ç™½åå•æœºåˆ¶

### 3. Web å·¥å…·

#### `WebSearchTool` - æœç´¢ç½‘é¡µ

ä½¿ç”¨ Brave Search APIï¼š

```python
class WebSearchTool(Tool):
    def __init__(self, api_key: str | None = None):
        self.api_key = api_key
    
    async def execute(self, query: str, count: int = 5) -> str:
        if not self.api_key:
            return "Web search not configured (missing API key)"
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://api.search.brave.com/res/v1/web/search",
                    headers={"X-Subscription-Token": self.api_key},
                    params={"q": query, "count": count}
                )
                response.raise_for_status()
                
                data = response.json()
                results = data.get("web", {}).get("results", [])
                
                formatted = []
                for i, result in enumerate(results, 1):
                    formatted.append(
                        f"{i}. {result['title']}\n"
                        f"   {result['url']}\n"
                        f"   {result['description']}"
                    )
                
                return "Search results:\n\n" + "\n\n".join(formatted)
        except Exception as e:
            return f"Error searching web: {str(e)}"
```

#### `WebFetchTool` - æŠ“å–ç½‘é¡µ

```python
async def execute(self, url: str) -> str:
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, timeout=10.0)
            response.raise_for_status()
            
            # ä½¿ç”¨ readability-lxml æå–ä¸»è¦å†…å®¹
            from readability import Document
            doc = Document(response.text)
            
            title = doc.title()
            content = doc.summary()  # HTML
            
            # ç®€å•çš„ HTML è½¬æ–‡æœ¬
            import re
            text = re.sub('<[^<]+?>', '', content)
            text = re.sub(r'\n\s*\n', '\n\n', text)
            
            return f"Page: {title}\n\n{text[:2000]}"  # é™åˆ¶é•¿åº¦
    except Exception as e:
        return f"Error fetching URL: {str(e)}"
```

### 4. æ¶ˆæ¯å·¥å…·

#### `MessageTool` - å‘é€æ¶ˆæ¯

å‘é€æ¶ˆæ¯åˆ°ç‰¹å®šæ¸ é“ï¼š

```python
class MessageTool(Tool):
    def __init__(self, send_callback):
        self.send_callback = send_callback
        self._channel = None
        self._chat_id = None
    
    def set_context(self, channel: str, chat_id: str):
        """Set the current conversation context."""
        self._channel = channel
        self._chat_id = chat_id
    
    async def execute(self, content: str, to: str | None = None) -> str:
        """
        Send a message.
        
        Args:
            content: Message content
            to: Optional override for chat_id
        """
        target_chat_id = to or self._chat_id
        
        if not target_chat_id:
            return "Error: No recipient specified"
        
        await self.send_callback(OutboundMessage(
            channel=self._channel,
            chat_id=target_chat_id,
            content=content
        ))
        
        return f"Message sent to {target_chat_id}"
```

**ç”¨é€”**ï¼š
- ä¸»åŠ¨å‘é€é€šçŸ¥
- å®šæ—¶ä»»åŠ¡çš„è¾“å‡º
- å­ä»£ç†çš„ç»“æœé€šçŸ¥

### 5. å­ä»£ç†å·¥å…·

#### `SpawnTool` - ç”Ÿæˆå­ä»£ç†

```python
class SpawnTool(Tool):
    def __init__(self, manager: SubagentManager):
        self.manager = manager
        self._channel = None
        self._chat_id = None
    
    def set_context(self, channel: str, chat_id: str):
        self._channel = channel
        self._chat_id = chat_id
    
    async def execute(
        self, 
        task: str, 
        announce: bool = True
    ) -> str:
        """
        Spawn a subagent to handle a task in the background.
        
        Args:
            task: Task description for the subagent
            announce: Whether to announce completion
        """
        origin = f"{self._channel}:{self._chat_id}"
        
        subagent_id = await self.manager.spawn(
            task=task,
            origin=origin,
            announce=announce
        )
        
        return f"Spawned subagent {subagent_id} to handle: {task}"
```

**åº”ç”¨åœºæ™¯**ï¼š
- é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡ï¼ˆå¦‚ç¼–è¯‘ä»£ç ï¼‰
- å®šæœŸç›‘æ§ï¼ˆå¦‚æ£€æŸ¥ç½‘ç«™æ›´æ–°ï¼‰
- å¤æ‚çš„å¤šæ­¥éª¤æ“ä½œ

## å·¥å…·æ‰§è¡Œæµç¨‹

è®©æˆ‘ä»¬è·Ÿè¸ªä¸€æ¬¡å®Œæ•´çš„å·¥å…·è°ƒç”¨ï¼š

### 1. LLM å†³å®šè°ƒç”¨å·¥å…·

ç”¨æˆ·ï¼š**"è¯»å– config.json æ–‡ä»¶"**

LLM è¿”å›ï¼š
```json
{
  "role": "assistant",
  "content": null,
  "tool_calls": [
    {
      "id": "call_abc123",
      "type": "function",
      "function": {
        "name": "read_file",
        "arguments": "{\"path\": \"config.json\"}"
      }
    }
  ]
}
```

### 2. Agent æ‰§è¡Œå·¥å…·

```python
for tool_call in response.tool_calls:
    # è§£æå‚æ•°
    args = json.loads(tool_call.function.arguments)
    # {"path": "config.json"}
    
    # æ‰§è¡Œå·¥å…·
    result = await self.tools.execute(
        name="read_file",
        arguments=args
    )
    # result = "File content of config.json:\n\n{...}"
```

### 3. å°†ç»“æœåé¦ˆç»™ LLM

```python
messages.append({
    "role": "tool",
    "tool_call_id": "call_abc123",
    "name": "read_file",
    "content": result
})
```

### 4. LLM çœ‹åˆ°ç»“æœåç»§ç»­æ¨ç†

```json
{
  "role": "assistant",
  "content": "è¿™ä¸ªé…ç½®æ–‡ä»¶åŒ…å«äº†ä»¥ä¸‹è®¾ç½®ï¼š..."
}
```

## å‚æ•°éªŒè¯

å·¥å…·ä½¿ç”¨ JSON Schema å®šä¹‰å‚æ•°ï¼š

```python
@property
def parameters(self) -> dict[str, Any]:
    return {
        "type": "object",
        "properties": {
            "path": {
                "type": "string",
                "description": "File path"
            },
            "content": {
                "type": "string",
                "description": "Content to write"
            }
        },
        "required": ["path", "content"]
    }
```

LLM ä¼šæ ¹æ® schema ç”Ÿæˆæ­£ç¡®çš„å‚æ•°ï¼Œä½†æœ€å¥½åœ¨ `execute()` ä¸­åšé¢å¤–éªŒè¯ï¼š

```python
async def execute(self, path: str, content: str) -> str:
    if not path:
        return "Error: path cannot be empty"
    
    if len(content) > 1_000_000:
        return "Error: content too large (max 1MB)"
    
    # ... å®é™…é€»è¾‘
```

## é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

### 1. æ•è·æ‰€æœ‰å¼‚å¸¸

```python
async def execute(self, **kwargs) -> str:
    try:
        # å·¥å…·é€»è¾‘
        return "Success"
    except FileNotFoundError as e:
        return f"File not found: {e.filename}"
    except PermissionError:
        return "Permission denied"
    except Exception as e:
        return f"Unexpected error: {str(e)}"
```

### 2. è¿”å›è¯¦ç»†é”™è¯¯ä¿¡æ¯

è®© LLM èƒ½å¤Ÿç†è§£é—®é¢˜å¹¶é‡‡å–è¡ŒåŠ¨ï¼š

```python
# âŒ ä¸å¥½
return "Error"

# âœ… å¥½
return "Error: File 'config.json' not found in /workspace. Available files: [...]"
```

### 3. è®°å½•æ—¥å¿—

```python
logger.error(f"Tool {self.name} failed: {e}")
logger.debug(f"Tool {self.name} called with args: {kwargs}")
```

## åˆ›å»ºè‡ªå®šä¹‰å·¥å…·

### ç¤ºä¾‹ï¼šå¤©æ°”æŸ¥è¯¢å·¥å…·

```python
import httpx
from nanobot.agent.tools.base import Tool

class WeatherTool(Tool):
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @property
    def name(self) -> str:
        return "get_weather"
    
    @property
    def description(self) -> str:
        return "Get current weather for a city"
    
    @property
    def parameters(self) -> dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "City name (e.g., 'London', 'Tokyo')"
                },
                "units": {
                    "type": "string",
                    "enum": ["metric", "imperial"],
                    "description": "Temperature units",
                    "default": "metric"
                }
            },
            "required": ["city"]
        }
    
    async def execute(self, city: str, units: str = "metric") -> str:
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://api.openweathermap.org/data/2.5/weather",
                    params={
                        "q": city,
                        "appid": self.api_key,
                        "units": units
                    }
                )
                response.raise_for_status()
                data = response.json()
                
                temp = data["main"]["temp"]
                desc = data["weather"][0]["description"]
                
                unit_symbol = "Â°C" if units == "metric" else "Â°F"
                return f"Weather in {city}: {desc}, {temp}{unit_symbol}"
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                return f"City '{city}' not found"
            return f"Error fetching weather: {e}"
        except Exception as e:
            return f"Unexpected error: {str(e)}"

# æ³¨å†Œå·¥å…·
agent.tools.register(WeatherTool(api_key="YOUR_API_KEY"))
```

## å·¥å…·ç»„åˆä½¿ç”¨

LLM å¯ä»¥æ™ºèƒ½åœ°ç»„åˆå¤šä¸ªå·¥å…·ï¼š

**ç”¨æˆ·**ï¼š**"æ‰¾åˆ°é¡¹ç›®ä¸­æ‰€æœ‰çš„ Python æ–‡ä»¶å¹¶ç»Ÿè®¡è¡Œæ•°"**

```
è¿­ä»£ 1:
  LLM â†’ exec(command="find . -name '*.py'")
  Tool â†’ è¿”å›æ–‡ä»¶åˆ—è¡¨
  
è¿­ä»£ 2:
  LLM â†’ exec(command="wc -l file1.py file2.py ...")
  Tool â†’ è¿”å›è¡Œæ•°ç»Ÿè®¡
  
è¿­ä»£ 3:
  LLM â†’ æ€»ç»“ç»“æœï¼š"æ‰¾åˆ° 15 ä¸ª Python æ–‡ä»¶ï¼Œå…± 2,345 è¡Œä»£ç "
```

## æ€§èƒ½ä¼˜åŒ–

### 1. ç¼“å­˜ç»“æœ

```python
class CachedWebFetchTool(WebFetchTool):
    def __init__(self):
        super().__init__()
        self._cache: dict[str, str] = {}
    
    async def execute(self, url: str) -> str:
        if url in self._cache:
            return self._cache[url]
        
        result = await super().execute(url)
        self._cache[url] = result
        return result
```

### 2. è¶…æ—¶æ§åˆ¶

```python
async def execute(self, command: str) -> str:
    try:
        result = await asyncio.wait_for(
            self._run_command(command),
            timeout=30.0  # 30 ç§’è¶…æ—¶
        )
        return result
    except asyncio.TimeoutError:
        return "Error: Command timed out after 30 seconds"
```

### 3. å¹¶å‘æ‰§è¡Œ

å¦‚æœ LLM è°ƒç”¨å¤šä¸ªç‹¬ç«‹çš„å·¥å…·ï¼Œå¯ä»¥å¹¶å‘æ‰§è¡Œï¼š

```python
# ä¸²è¡Œæ‰§è¡Œï¼ˆå½“å‰å®ç°ï¼‰
for tool_call in response.tool_calls:
    result = await self.tools.execute(tool_call.name, tool_call.arguments)

# å¹¶å‘æ‰§è¡Œï¼ˆä¼˜åŒ–ï¼‰
tasks = [
    self.tools.execute(tc.name, tc.arguments)
    for tc in response.tool_calls
]
results = await asyncio.gather(*tasks)
```

## å°ç»“

é€šè¿‡æœ¬ç« ï¼Œä½ åº”è¯¥æŒæ¡äº†ï¼š
- âœ… å·¥å…·çš„æŠ½è±¡è®¾è®¡ï¼ˆTool åŸºç±»ï¼‰
- âœ… å·¥å…·æ³¨å†Œè¡¨çš„å®ç°
- âœ… æ‰€æœ‰å†…ç½®å·¥å…·çš„åŠŸèƒ½å’Œç”¨æ³•
- âœ… å·¥å…·æ‰§è¡Œçš„å®Œæ•´æµç¨‹
- âœ… å¦‚ä½•åˆ›å»ºè‡ªå®šä¹‰å·¥å…·

**å…³é”®è¦ç‚¹**ï¼š
- å·¥å…·æ˜¯ Agent ä¸å¤–ç•Œäº¤äº’çš„å”¯ä¸€æ–¹å¼
- æ‰€æœ‰å·¥å…·éµå¾ªç»Ÿä¸€æ¥å£ï¼ˆname, description, parameters, executeï¼‰
- JSON Schema ç”¨äºå®šä¹‰å‚æ•°æ ¼å¼
- é”™è¯¯å¤„ç†è‡³å…³é‡è¦ï¼ˆè¿”å›å¯ç†è§£çš„é”™è¯¯ä¿¡æ¯ï¼‰

**ä¸‹ä¸€æ­¥**ï¼š[10-æŠ€èƒ½ç³»ç»Ÿ.md](./nanobot/2026-02-03/10-æŠ€èƒ½ç³»ç»Ÿ.md) - äº†è§£å¦‚ä½•æ‰©å±• Agent çš„èƒ½åŠ›ã€‚
