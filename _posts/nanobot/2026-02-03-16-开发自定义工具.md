# ç¬¬ä¸ƒå±‚ï¼šå¼€å‘è‡ªå®šä¹‰å·¥å…·

> ğŸ“Œ **å‚è€ƒ**ï¼š[08-å·¥å…·ç³»ç»Ÿæ¶æ„.md](./nanobot/2026-02-03/08-å·¥å…·ç³»ç»Ÿæ¶æ„.md)

## å¿«é€Ÿå¼€å§‹

### 1. æœ€ç®€å·¥å…·æ¨¡æ¿

```python
from nanobot.agent.tools.base import Tool

class HelloTool(Tool):
    @property
    def name(self) -> str:
        return "hello"
    
    @property
    def description(self) -> str:
        return "Say hello to someone"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name to greet"
                }
            },
            "required": ["name"]
        }
    
    async def execute(self, name: str) -> str:
        return f"Hello, {name}!"

# æ³¨å†Œ
agent.tools.register(HelloTool())
```

### 2. æµ‹è¯•å·¥å…·

```python
import asyncio

# å•å…ƒæµ‹è¯•
async def test_hello():
    tool = HelloTool()
    result = await tool.execute(name="Alice")
    assert result == "Hello, Alice!"

asyncio.run(test_hello())
```

## è¿›é˜¶ç¤ºä¾‹

### ç¤ºä¾‹ 1ï¼šHTTP API è°ƒç”¨

```python
import httpx
from typing import Any

class WeatherTool(Tool):
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @property
    def name(self) -> str:
        return "get_weather"
    
    @property
    def description(self) -> str:
        return "Get weather for a city"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "City name"
                }
            },
            "required": ["city"]
        }
    
    async def execute(self, city: str) -> str:
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://api.openweathermap.org/data/2.5/weather",
                    params={"q": city, "appid": self.api_key}
                )
                response.raise_for_status()
                
                data = response.json()
                temp = data["main"]["temp"] - 273.15  # K to C
                desc = data["weather"][0]["description"]
                
                return f"{city}: {temp:.1f}Â°C, {desc}"
        
        except httpx.HTTPError as e:
            return f"Error fetching weather: {e}"
```

### ç¤ºä¾‹ 2ï¼šæ•°æ®åº“æŸ¥è¯¢

```python
import sqlite3

class DBQueryTool(Tool):
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    @property
    def name(self) -> str:
        return "query_db"
    
    @property
    def description(self) -> str:
        return "Execute SQL query on database"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "SQL query (SELECT only)"
                }
            },
            "required": ["query"]
        }
    
    async def execute(self, query: str) -> str:
        # å®‰å…¨æ£€æŸ¥
        if not query.strip().upper().startswith("SELECT"):
            return "Error: Only SELECT queries allowed"
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.execute(query)
            rows = cursor.fetchall()
            conn.close()
            
            if not rows:
                return "No results"
            
            # æ ¼å¼åŒ–ç»“æœ
            return "\n".join([str(row) for row in rows])
        
        except Exception as e:
            return f"Error: {e}"
```

### ç¤ºä¾‹ 3ï¼šä½¿ç”¨ç¬¬ä¸‰æ–¹åº“

```python
from PIL import Image

class ImageInfoTool(Tool):
    @property
    def name(self) -> str:
        return "image_info"
    
    @property
    def description(self) -> str:
        return "Get image information"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "Path to image"
                }
            },
            "required": ["path"]
        }
    
    async def execute(self, path: str) -> str:
        try:
            img = Image.open(path)
            return f"Size: {img.size}, Format: {img.format}, Mode: {img.mode}"
        except Exception as e:
            return f"Error: {e}"
```

## æœ€ä½³å®è·µ

### 1. å‚æ•°éªŒè¯

```python
@property
def parameters(self) -> dict:
    return {
        "type": "object",
        "properties": {
            "count": {
                "type": "integer",
                "description": "Number of items",
                "minimum": 1,
                "maximum": 100
            },
            "format": {
                "type": "string",
                "description": "Output format",
                "enum": ["json", "csv", "text"]
            }
        },
        "required": ["count"]
    }
```

### 2. é”™è¯¯å¤„ç†

```python
async def execute(self, **kwargs) -> str:
    try:
        result = await self.do_work(**kwargs)
        return result
    
    except ValueError as e:
        return f"Invalid input: {e}"
    
    except httpx.HTTPError as e:
        return f"Network error: {e}"
    
    except Exception as e:
        logger.exception("Unexpected error in tool")
        return f"Error: {e}"
```

### 3. æ·»åŠ æ—¥å¿—

```python
from loguru import logger

async def execute(self, url: str) -> str:
    logger.info(f"Fetching URL: {url}")
    
    try:
        result = await fetch(url)
        logger.debug(f"Got {len(result)} bytes")
        return result
    except Exception as e:
        logger.error(f"Failed to fetch {url}: {e}")
        return f"Error: {e}"
```

### 4. è¶…æ—¶æ§åˆ¶

```python
import asyncio

async def execute(self, url: str) -> str:
    try:
        result = await asyncio.wait_for(
            self.fetch_url(url),
            timeout=30.0
        )
        return result
    except asyncio.TimeoutError:
        return "Error: Request timeout"
```

## å·¥å…·æ³¨å†Œ

### åœ¨ AgentLoop ä¸­æ³¨å†Œ

ä¿®æ”¹ `_register_default_tools`ï¼š

```python
def _register_default_tools(self):
    # ...ç°æœ‰å·¥å…·...
    
    # è‡ªå®šä¹‰å·¥å…·
    self.tools.register(WeatherTool(api_key=self.weather_api_key))
    self.tools.register(DBQueryTool(db_path=str(self.workspace / "data.db")))
```

### åŠ¨æ€åŠ è½½å·¥å…·

```python
def load_custom_tools(self, tools_dir: Path):
    """ä»ç›®å½•åŠ è½½è‡ªå®šä¹‰å·¥å…·"""
    import importlib.util
    
    for tool_file in tools_dir.glob("*_tool.py"):
        # åŠ¨æ€å¯¼å…¥
        spec = importlib.util.spec_from_file_location(
            tool_file.stem, tool_file
        )
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        # æŸ¥æ‰¾ Tool å­ç±»
        for name in dir(module):
            obj = getattr(module, name)
            if isinstance(obj, type) and issubclass(obj, Tool) and obj != Tool:
                self.tools.register(obj())
```

## å¼€å‘å·¥ä½œæµ

1. **åˆ›å»ºå·¥å…·æ–‡ä»¶**ï¼š`my_tool.py`
2. **å®ç° Tool æ¥å£**
3. **æœ¬åœ°æµ‹è¯•**ï¼š`pytest` æˆ–æ‰‹åŠ¨æµ‹è¯•
4. **æ³¨å†Œåˆ° Agent**
5. **é€šè¿‡å¯¹è¯æµ‹è¯•**

## å°ç»“

- âœ… ç»§æ‰¿ `Tool` åŸºç±»å¹¶å®ç° 4 ä¸ªå±æ€§/æ–¹æ³•
- âœ… ä½¿ç”¨ JSON Schema å®šä¹‰å‚æ•°
- âœ… è¿”å›å­—ç¬¦ä¸²ç»“æœ
- âœ… å®Œå–„çš„é”™è¯¯å¤„ç†

**å‚è€ƒ**ï¼š[08-å·¥å…·ç³»ç»Ÿæ¶æ„.md](./nanobot/2026-02-03/08-å·¥å…·ç³»ç»Ÿæ¶æ„.md) äº†è§£æ›´å¤š

**ä¸‹ä¸€æ­¥**ï¼š[17-å¼€å‘è‡ªå®šä¹‰æŠ€èƒ½.md](./nanobot/2026-02-03/17-å¼€å‘è‡ªå®šä¹‰æŠ€èƒ½.md)
